
File: C:\Users\Foarvad\Projects\home-poker-software\packages\api\src\app.module.ts

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'postgres',
      host: 'localhost',
      port: 49153,
      username: 'postgres',
      password: 'postgrespw',
      database: 'postgres',
      autoLoadEntities: true,
      synchronize: true,
    }),
  ],
})
export class AppModule {}


====================


File: C:\Users\Foarvad\Projects\home-poker-software\packages\api\src\main.ts

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();


====================


File: C:\Users\Foarvad\Projects\home-poker-software\packages\api\src\types.ts

export type User = {
  username: string;
  displayName: string;
};

// Poker session

export type HoldemPokerSession = {
  id: string;
  name: string;
  players: User[];
  hands: HoldemPokerHand[];
};

// One hand from the game (with board and player hands info)

export type HoldemPokerHand = {
  number: number;
  board: HoldemBoard;
  playersData: HoldemPokerHandPlayerData[];
};

// Player info in specific poker hand

export type HoldemPokerHandPlayerData = {
  player: User;
  hand: HoldemPlayerHand;
};

// 52 Card deck

export type PlayingCardRank =
  | '2'
  | '3'
  | '4'
  | '5'
  | '6'
  | '7'
  | '8'
  | '9'
  | 'T'
  | 'J'
  | 'Q'
  | 'K'
  | 'A';

export enum PlayingCardSuit {
  SPADE = 's',
  HEART = 'h',
  CLUB = 'c',
  DIAMOND = 'd',
}

export type PlayingCard = {
  rank: PlayingCardRank;
  suit: PlayingCardSuit;
};

// Card combinations

export type HoldemBoard = {
  flop: [PlayingCard, PlayingCard, PlayingCard];
  turn: PlayingCard;
  river: PlayingCard;
};

export type HoldemPlayerHand = [PlayingCard, PlayingCard];


====================


File: C:\Users\Foarvad\Projects\home-poker-software\packages\api\src\holdem\holdem.gateway.ts

import { WebSocketGateway, WebSocketServer } from '@nestjs/websockets';
import { Server } from 'socket.io';

@WebSocketGateway({
  cors: {
    origin: '*',
  },
})
export class HoldemGateway {
  @WebSocketServer()
  server: Server;
}


====================


File: C:\Users\Foarvad\Projects\home-poker-software\packages\api\src\holdem\holdem.model.ts

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

import { HoldemSession } from './entities/holdem-session.entity';
import { HoldemHand } from './entities/holdem-hand.entity';
import { HoldemPlayerHand } from './entities/holdem-player-hand.entity';

import { HoldemService } from './holdem.service';
import { HoldemGateway } from './holdem.gateway';

@Module({
  imports: [
    TypeOrmModule.forFeature([HoldemSession, HoldemHand, HoldemPlayerHand]),
  ],
  providers: [HoldemService, HoldemGateway],
})
export class HoldemModel {}


====================


File: C:\Users\Foarvad\Projects\home-poker-software\packages\api\src\holdem\holdem.service.ts

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource, Repository } from 'typeorm';

import { HoldemSession } from './entities/holdem-session.entity';
import { HoldemHand } from './entities/holdem-hand.entity';
import { HoldemPlayerHand } from './entities/holdem-player-hand.entity';
import { CreateSessionDto } from './dto/create-session.dto';
import { AddPlayerHandDto } from './dto/add-player-hand.dto';
import { HoldemServiceErrorType, HoldemSessionStatus } from './holdem.types';

export class HoldemServiceError extends Error {
  constructor(type: HoldemServiceErrorType, message: string) {
    super(message);
    this.name = 'HoldemServiceError';
    this.type = type;
  }

  public type: HoldemServiceErrorType;
}

@Injectable()
export class HoldemService {
  constructor(
    private dataSource: DataSource,
    @InjectRepository(HoldemSession)
    private readonly sessionsRepository: Repository<HoldemSession>,
    @InjectRepository(HoldemHand)
    private readonly handsRepository: Repository<HoldemHand>,
    @InjectRepository(HoldemPlayerHand)
    private readonly playerHandsRepository: Repository<HoldemPlayerHand>,
  ) {}

  // Helpers

  private async findSessionById(sessionId: string) {
    const session = await this.sessionsRepository.findOne({
      relations: { currentHand: true },
      where: { id: sessionId },
    });

    if (!session) {
      throw new HoldemServiceError(
        HoldemServiceErrorType.SESSION_NOT_FOUND,
        'Session not found.',
      );
    }

    return session;
  }

  private async findCurrentHandBySessionId(sessionId: string) {
    const session = await this.findSessionById(sessionId);

    if (!session.currentHand) {
      throw new HoldemServiceError(
        HoldemServiceErrorType.NO_ACTIVE_HAND,
        'Session has no active hand at the moment.',
      );
    }

    return session.currentHand;
  }

  // Main methods

  async createSession(
    createSessionDto: CreateSessionDto,
  ): Promise<HoldemSession> {
    const session = this.sessionsRepository.create({
      name: createSessionDto.name,
      status: HoldemSessionStatus.NOT_STARTED,
    });

    return this.sessionsRepository.save(session);
  }

  async startSession(sessionId: string) {
    const session = await this.findSessionById(sessionId);

    if (session.status !== HoldemSessionStatus.NOT_STARTED) {
      throw new HoldemServiceError(
        HoldemServiceErrorType.INCORRECT_SESSION_STATUS,
        'Session is already started or was ended.',
      );
    }

    await this.dataSource.transaction(async (manager) => {
      // Create first hand
      const firstHand = manager.create(HoldemHand, {
        number: 1,
        session,
      });

      // Save first hand
      await manager.getRepository(HoldemHand).save(firstHand);

      // Update session
      await manager.getRepository(HoldemSession).update(session.id, {
        currentHand: firstHand,
        status: HoldemSessionStatus.ACTIVE,
        startedAt: new Date(),
      });
    });
  }

  async endSession(sessionId: string) {
    const session = await this.findSessionById(sessionId);

    if (session.status === HoldemSessionStatus.ENDED) {
      throw new HoldemServiceError(
        HoldemServiceErrorType.INCORRECT_SESSION_STATUS,
        'Session is already ended.',
      );
    }

    await this.sessionsRepository.update(session.id, {
      currentHand: null,
      status: HoldemSessionStatus.ENDED,
      endedAt: new Date(),
    });
  }

  async nextHand(sessionId: string) {
    const session = await this.findSessionById(sessionId);

    if (session.status !== HoldemSessionStatus.ACTIVE) {
      throw new HoldemServiceError(
        HoldemServiceErrorType.INCORRECT_SESSION_STATUS,
        'Session is not active.',
      );
    }

    if (!session.currentHand) {
      throw new HoldemServiceError(
        HoldemServiceErrorType.NO_ACTIVE_HAND,
        'Session is active, but current hand is null.',
      );
    }

    const nextHandNumber = session.currentHand.number + 1;

    await this.dataSource.transaction(async (manager) => {
      // Create new hand
      const newHand = manager.create(HoldemHand, {
        number: nextHandNumber,
        session,
      });

      // Save new hand
      await manager.getRepository(HoldemHand).save(newHand);

      // Update session
      await manager.getRepository(HoldemSession).update(session.id, {
        currentHand: newHand,
      });
    });
  }

  async addPlayerHand(sessionId: string, addPlayerHandDto: AddPlayerHandDto) {
    const currentHand = await this.findCurrentHandBySessionId(sessionId);

    const existingPlayerHand = await this.playerHandsRepository.findOne({
      where: {
        playerName: addPlayerHandDto.playerName,
        hand: { id: currentHand.id },
      },
    });

    if (existingPlayerHand) {
      throw new HoldemServiceError(
        HoldemServiceErrorType.PLAYER_HAND_ALREADY_EXISTS,
        `Could not add player hand. This player's hand was already submitted.`,
      );
    }

    const playerHand = this.playerHandsRepository.create({
      playerName: addPlayerHandDto.playerName,
      playerHand: addPlayerHandDto.playerHand,
      hand: currentHand,
    });

    await this.playerHandsRepository.save(playerHand);
  }

  async addFlop(sessionId: string, flop: string) {
    const currentHand = await this.findCurrentHandBySessionId(sessionId);

    if (flop.length !== 6) {
      throw new HoldemServiceError(
        HoldemServiceErrorType.INVALID_FLOP,
        'Invalid flop. It should be in "5hAsQd" format (6 chars long).',
      );
    }

    await this.handsRepository.update(currentHand.id, { flop });
  }

  async addTurn(sessionId: string, turn: string) {
    const currentHand = await this.findCurrentHandBySessionId(sessionId);

    if (turn.length !== 2) {
      throw new HoldemServiceError(
        HoldemServiceErrorType.INVALID_TURN_OR_RIVER,
        'Invalid turn. It should be in "Qd" format (2 chars long).',
      );
    }

    await this.handsRepository.update(currentHand.id, { turn });
  }

  async addRiver(sessionId: string, river: string) {
    const currentHand = await this.findCurrentHandBySessionId(sessionId);

    if (river.length !== 2) {
      throw new HoldemServiceError(
        HoldemServiceErrorType.INVALID_TURN_OR_RIVER,
        'Invalid river. It should be in "Qd" format (2 chars long).',
      );
    }

    await this.handsRepository.update(currentHand.id, { river });
  }
}


====================


File: C:\Users\Foarvad\Projects\home-poker-software\packages\api\src\holdem\holdem.types.ts

export enum HoldemSessionStatus {
  NOT_STARTED = 'NOT_STARTED',
  ACTIVE = 'ACTIVE',
  ENDED = 'ENDED',
}

export enum HoldemServiceErrorType {
  SESSION_NOT_FOUND,
  INCORRECT_SESSION_STATUS,
  NO_ACTIVE_HAND,
  PLAYER_HAND_ALREADY_EXISTS,
  INVALID_FLOP,
  INVALID_TURN_OR_RIVER,
}


====================


File: C:\Users\Foarvad\Projects\home-poker-software\packages\api\src\holdem\dto\add-player-hand.dto.ts

export class AddPlayerHandDto {
  playerName: string;
  playerHand: string;
}


====================


File: C:\Users\Foarvad\Projects\home-poker-software\packages\api\src\holdem\dto\create-session.dto.ts

export class CreateSessionDto {
  name: string;
}


====================


File: C:\Users\Foarvad\Projects\home-poker-software\packages\api\src\holdem\entities\holdem-hand.entity.ts

import {
  Column,
  Entity,
  ManyToOne,
  OneToMany,
  PrimaryGeneratedColumn,
} from 'typeorm';

import { HoldemPlayerHand } from './holdem-player-hand.entity';
import { HoldemSession } from './holdem-session.entity';

@Entity()
export class HoldemHand {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  number: number;

  @Column({ nullable: true })
  flop: string | null; // 5hAsQd

  @Column({ nullable: true })
  turn: string | null; // Qs

  @Column({ nullable: true })
  river: string | null; // Jh

  @OneToMany(() => HoldemPlayerHand, (playerHand) => playerHand.hand)
  playerHands: HoldemPlayerHand[];

  @ManyToOne(() => HoldemSession, (session) => session.hands)
  session: HoldemSession;
}


====================


File: C:\Users\Foarvad\Projects\home-poker-software\packages\api\src\holdem\entities\holdem-player-hand.entity.ts

import { Column, Entity, ManyToOne, PrimaryGeneratedColumn } from 'typeorm';

import { HoldemHand } from './holdem-hand.entity';

@Entity()
export class HoldemPlayerHand {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  playerName: string;

  @Column()
  playerHand: string; // 5hAs

  @ManyToOne(() => HoldemHand)
  hand: HoldemHand;
}


====================


File: C:\Users\Foarvad\Projects\home-poker-software\packages\api\src\holdem\entities\holdem-session.entity.ts

import {
  Column,
  CreateDateColumn,
  Entity,
  OneToMany,
  PrimaryGeneratedColumn,
} from 'typeorm';

import { HoldemSessionStatus } from '../holdem.types';

import { HoldemHand } from './holdem-hand.entity';

@Entity()
export class HoldemSession {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  name: string;

  @Column({ type: 'enum', default: HoldemSessionStatus.NOT_STARTED })
  status: HoldemSessionStatus;

  @CreateDateColumn()
  createdAt: Date;

  @Column({ type: 'timestamptz', nullable: true })
  startedAt: Date | null;

  @Column({ type: 'timestamptz', nullable: true })
  endedAt: Date | null;

  @OneToMany(() => HoldemHand, (hand) => hand.session)
  hands: HoldemHand[];

  @Column({ nullable: true })
  currentHand: HoldemHand | null;
}


====================

